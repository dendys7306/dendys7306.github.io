<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="format-detection" content="telephone=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="MobileOptimized" content="176" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="robots" content="noindex,nofollow" />
    <script src="https://telegram.org/js/telegram-web-app.js?2"></script>
    <script>
        function setThemeClass() {
            document.documentElement.className = Telegram.WebApp.colorScheme;
        }

        Telegram.WebApp.onEvent('themeChanged', setThemeClass);
        setThemeClass();

    </script>
    <title>Trojbublina v0.1</title>    
    <style>
        body {
            --bg-color: var(--tg-theme-bg-color, #fff);
            font-family: sans-serif;
            background-color: var(--bg-color);
            color: var(--tg-theme-text-color, #222);
            font-size: 14px;
            margin: 0;
            padding: 0;
            color-scheme: var(--tg-color-scheme);
        }

        body.gray {
            background-color: var(--tg-theme-secondary-bg-color, #efefef);
        }

        a {
            color: var(--tg-theme-link-color, #2678b6);
        }

        .btn {
            font-size: 14px;
            padding: 10px 17px;
        }

        .btn-primary {
            background-color: var(--tg-theme-button-color, #50a8eb);
            color: var(--tg-theme-button-text-color, #fff);
            border: none;
        }

        button {
            display: block;
            width: 100%;
            font-size: 14px;
            margin: 15px 0;
            padding: 12px 20px;
            border: none;
            border-radius: 4px;
            background-color: var(--tg-theme-button-color, #50a8eb);
            color: var(--tg-theme-button-text-color, #ffffff);
            cursor: pointer;
        }

        .main-container {
            padding: 15px;
        }

        .list-header {
            text-transform: uppercase;
            font-size: .92em;
            color: var(--tg-theme-hint-color, #ccc);
            margin: 0 0 10px;
        }

        a.list-group-item,
        button.list-group-item {
            color: var(--tg-theme-text-color, #222);
        }

        .main-container p {
            margin: 0 0 10px;
        }

        .main-container pre,
        .main-container > .btn {
            margin: 0 0 7px;
        }

        .main-container pre + .hint,
        .main-container > .btn + .hint {
            text-align: center;
            margin: 0 0 15px;
        }

        button[disabled] {
            opacity: 0.6;
            cursor: auto;
            pointer-events: none;
        }

        button.close_btn {
            /*position: fixed;*/
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 0;
            margin: 0;
            padding: 16px 20px;
            text-transform: uppercase;
        }

        input[type="text"],
        .input[contenteditable] {
            display: block;
            box-sizing: border-box;
            font-size: 14px;
            width: 100%;
            padding: 12px 20px;
            margin: 15px 0;
            border: 1px solid var(--tg-theme-link-color, #000);
            background-color: var(--tg-theme-bg-color, #ffffff);
            border-radius: 4px;
            color: var(--tg-theme-text-color, #222222);
            text-align: start;
        }

        input[type="text"]::-webkit-input-placeholder {
            color: var(--tg-theme-hint-color, #ccc);
        }

        input[type="text"]::-moz-placeholder {
            color: var(--tg-theme-hint-color, #ccc);
        }

        input[type="text"]:-ms-input-placeholder {
            color: var(--tg-theme-hint-color, #ccc);
        }

        .input[data-placeholder] {
            position: relative;
        }

        .input[data-placeholder]:empty:before {
            position: absolute;
            left: 0;
            right: 0;
            content: attr(data-placeholder);
            color: var(--tg-theme-hint-color, #ccc);
            padding: 0 20px;
            font-weight: normal;
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
            pointer-events: none;
            z-index: -1;
        }

        section {
            padding: 15px;
            text-align: center;
            background-color: var(--bg-color, #ffffff);
        }

        section#top_sect {
            background-color: var(--tg-theme-bg-color, #ffffff);
        }

        section#top_sect.second {
            background-color: var(--tg-theme-secondary-bg-color, #efefef);
        }

        section .sect_row {
            margin: 10px 0;
        }

        section + section {
            padding: 0 15px 65px;
        }

        p {
            margin: 40px 0 15px;
        }

        ul {
            text-align: left;
        }

        li {
            color: var(--tg-theme-hint-color, #a8a8a8);
        }

        textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 7px;
        }

        pre {
            background: rgba(0, 0, 0, .07);
            color: var(--tg-theme-text-color, #222);
            font-size: 12px;
            border: none;
            border-radius: 4px;
            padding: 8px;
            margin: 7px 0;
            word-break: break-word;
            white-space: pre-wrap;
            text-align: left;
        }

        .dark pre {
            background: rgba(255, 255, 255, .15);
        }

        .chat_img {
            width: 30px;
            border-radius: 15px;
            margin-right: 10px;
        }

        .columns {
            display: flex;
        }

        .columns > * {
            flex-grow: 1;
        }

        .hint {
            font-size: .8em;
            color: var(--tg-theme-hint-color, #a8a8a8);
        }

        .ok {
            color: green;
        }

        .err {
            color: red;
        }

        .status_need {
            display: none;
        }

        #fixed_wrap {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            transform: translateY(100vh);
        }

        .viewport-container {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            height: var(--tg-viewport-stable-height, 100vh);
            transition: height .2s ease;
        }

        .viewport-container .main-container {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .viewport-container .main-container button {
            width: auto;
        }

        .viewport-border,
        .viewport-stable_border {
            position: fixed;
            left: 0;
            right: 0;
            top: 0;
            height: var(--tg-viewport-height, 100vh);
            pointer-events: none;
        }

        .viewport-stable_border {
            height: var(--tg-viewport-stable-height, 100vh);
        }

        .viewport-border:before,
        .viewport-stable_border:before {
            content: attr(text);
            display: inline-block;
            position: absolute;
            background: gray;
            right: 0;
            top: 0;
            font-size: 7px;
            padding: 2px 4px;
            vertical-align: top;
        }

        .viewport-stable_border:before {
            background: green;
            left: 0;
            right: auto;
        }

        .viewport-border:after,
        .viewport-stable_border:after {
            content: '';
            display: block;
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            border: 2px dashed gray;
        }

        .viewport-stable_border:after {
            border-color: green;
        }

        small {
            font-size: 12px;
        }
        .small {
            font-size: 12px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }
        .table td {
            padding: 2px;
        }
        .table-bordered {
            border: 1px solid var(--tg-theme-hint-color, #ccc);
        }
        .table-bordered th, .table-bordered td {
            border: 1px solid var(--tg-theme-hint-color, #ccc);
            padding: 4px;
        }
        .table.small button {
            padding: 3px 6px;
            font-size: 12px;
            margin: 4px 0;
        }
        .table.small input {
            padding: 3px 6px;
            font-size: 12px;
            margin: 4px 0;
        }

        canvas {
            border: 1px solid rgb(69, 69, 69);
        }
    </style>

</head>

<body class="" style="visibility: hidden;>
    
    <div style="font-family: monospace; font-size: 16px; color: #696969;">
        19ABD511Pravda (hranice to/ne-to)<br/>
        2778A724Dobro (rozvoj společný)<br/>
        35498933Krása (individuální)
    </div>
    
    <textarea id="inputData" style="width: 360px; height: 150px; overflow: auto; font-family: monospace; font-size: 16px;" rows="7" cols="80" placeholder="17ABD932Pravda (hranice to/ne-to)"></textarea> 
    <button onclick="parseData()">přepočítat</button>
    <button onclick="alert('1x idéčko \n1x velikost (1-9)\n3x barva v hex (AB8)\n1x transparentnost (1-9)\n1x border type (1 ..., 2 --, other normal)\n1x border thickness (1-9)\ntext');">popis</button>
    <canvas id="myCanvas" width="360" height="400"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let circles = []

        // text general properties
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        /* is dark color to switch font ... */
        function isColorDark(color) {

            // expand three char hex to six
            if ( color.length === 4 ) {
                color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
            }
            
            // Convert hex color to RGB
            let r = parseInt(color.substr(1, 2), 16);
            let g = parseInt(color.substr(3, 2), 16);
            let b = parseInt(color.substr(5, 2), 16);

            // Calculate luminance
            let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

            // Return true if the color is dark, false otherwise
            return luminance < 128;
        }        

        /* parsing data */
        function parseData() {
            
            // Get the input data
            const inputData = document.getElementById('inputData').value;
            
            // Split the input data into lines
            const lines = inputData.split('\n');
            
            const regex = /^(.)(.)(.{3})(.)(.)(.)(.*)$/;

            // Iterate over each line and parse the data
            lines.forEach(line => {

                const match = line.match(regex);

                //console.log( "preparing line with id: " + parseInt(match[1]) )

                // entry with given id exists
                const index = circles.findIndex(circles => circles.id === parseInt(match[1]));

                if (index !== -1) {

                    circleUpdates = {

                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text

                    }

                    // Update the object at the found index
                    circles[index] = {
                        ...circles[index],
                        ...circleUpdates
                    };

                } else {

                    // Create a circle object and add it to the array
                    const circle = {
                        x: canvas.width / 2,
                        y: canvas.height / 2, 
                        selected : false,
                        id: parseInt(match[1]),                // 1x - id  
                        radius: parseInt(match[2]),            // 1x - radius  
                        color: '#' + match[3].trim(),          // 3x - color in hex
                        transparent : parseInt(match[4]),      // 1x - transparent
                        borderTyp : match[5],                  // 1x - border typ (1 dotted, 2 lined, other normal)
                        borderThick : match[6],                // 1x - border thickness
                        text : match[7]                        // Nx - text
                    };
                    circles.push(circle);
                }
            });
            
            //console.log(circles);
            //circles.sort( (a,b) => a.id - b.id );
            //console.log(circles);

            drawCircles();
        }

        /* count letter ofr the whole circle depending on radius (1-9) */
        function countOfLetter( radius ){

            let output = 9;
            for (let i = radius; i > 0; i--) {
                output += i;
            }
            output = Math.trunc(output * 1.8)
            output2 = Math.trunc(exponentialFunction(radius + 3)+(radius*5))
            //console.log("pocet pismen: " + radius + " " + output + " " + output2 );
           
            if ( radius > 2 && radius <= 6 ){
                output = output + 5
            } else if ( radius >6 ) {
                output = output - 5
            }

            return output
        }

        /* calculate radius in pixels for given 1 .. 9 */
        function getRadiusInPixel(radius){
            return 10 + ((radius-1) * 20)
        }

        /* funkce s exponentem */
        function exponentialFunction(x) {
            const a = 3; // základ exponenciální funkce
            const k = 0.31; // konstanta určující míru růstu
            return Math.pow(a, k * x);
        }

        /* canvas zoom */
        function zoomCanvas(scaleFactor) {
            ctx.save(); // Save the current state
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            //canvas.width *= scaleFactor;
            //canvas.height *= scaleFactor;

            ctx.scale(scaleFactor, scaleFactor); // Scale the canvas
            // Redraw your content here
            drawCircles()

            ctx.restore(); // Restore the original state
        }        

        /* handling selection variables */
        let endMove = false
        let moved = false
        let selecting = true

        /* draw circles function */ 
        function drawCircles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // order ascending - may be do it better way not to sort every draw
            circles.sort( (a, b) => a.id - b.id ).forEach(circle => {               
            //circles.forEach(circle => {               
                ctx.beginPath();

                radiusCircle = getRadiusInPixel(circle.radius)
                //console.log( "CIRCLE: " + circle.id + " -> " + circle.x + "  " + circle.y )
                ctx.arc(circle.x, circle.y, radiusCircle, 0, 2 * Math.PI);
                ctx.fillStyle = circle.color;

                ctx.globalAlpha = circle.transparent / 10;
                ctx.fill();

                if ( circle.selected ){
                    //console.log("selected in draw " + circle.selected)

                    ctx.strokeStyle = 'yellow'; // Set border color to yellow
                    ctx.lineWidth = 3; // Set border width to 3px

                } else {
                    let borderColor = '#000000'
                    if (isColorDark( circle.color )){
                        borderColor = '#FFFFFF'
                    }

                    ctx.strokeStyle = borderColor; // Set border color to gray
                    ctx.lineWidth = circle.borderThick; // Set border width to 3px
                }

                switch ( circle.borderTyp ){
                    case '1': 
                        ctx.setLineDash([2, 3]); // [dash length, gap length] 
                        break
                    case '2':
                        ctx.setLineDash([5, 2]); // [dash length, gap length] 
                        break
                    default:
                        ctx.setLineDash([4, 0]);// [dash length, gap length] 
                }    

                ctx.stroke();

                // text placement
                // radius for text
                const radiusText = radiusCircle - (8+(circle.radius*0.5));
                //const angleStep = (Math.PI * 2) / circle.text.length;

                countOfLetters = countOfLetter( circle.radius );
                //console.log(circle.radius + " - pocet pismen: " + countOfLetters);
                const angleStep = (Math.PI * 2) / countOfLetters;

                //const startAngle = Math.PI;
                //const endAngle = 2 * Math.PI;

                fuga = ((( countOfLetters / 2 ) - circle.text.length ) /2 ) /  ( countOfLetters / 2 )  * Math.PI
                //console.log( "fuga: " + fuga );

                const startAngle = Math.PI + fuga + ( angleStep / 2 );
                const endAngle = ( 2 * Math.PI ) - fuga;

                //textSize = 10 + circle.radius - 1;
                textSize = 8 + ((circle.radius - 1)*1.5);
                ctx.font = "bold "+ textSize + "px Times";

                for (let i = 0; i < circle.text.length; i++) {
                    //const angle = i * angleStep;
                    var angle = startAngle + (i / circle.text.length) * (endAngle - startAngle);

                    const x = circle.x + radiusText * Math.cos(angle);
                    const y = circle.y + radiusText * Math.sin(angle);
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + Math.PI / 2);

                    let textColor = '#000000'
                    if (isColorDark( circle.color )){
                        textColor = '#FFFFFF'
                    }

                    ctx.fillStyle = textColor;
                    //ctx.fillStyle = 'black';
                    ctx.fillText(circle.text[i], 0, 0);
                    ctx.restore();
                }

            });

            //console.log( "end drawing" );
        }

        /* get touched position */
        function getTouchPos(canvas, event) {

            const rect = canvas.getBoundingClientRect();
            return {
                x: event.touches ? event.touches[0].clientX - rect.left : event.clientX - rect.left,
                y: event.touches ? event.touches[0].clientY - rect.top : event.clientY - rect.top 
            };
        }


        let startPos = null
        let startVector = null
        let isTouched = false;

        /* handle start event */
        function handleStart( e ){

            // prevent quick doubletouch
            if (isTouched) {
                e.preventDefault();
                return false;
            }
            isTouched = true;
            setTimeout(() => {
                isTouched = false;
            }, 200);  // Adjust the timeout as needed


            // do nothing when move is active
            if ( moved ){
                return
            }
       
            //console.log( 'starting move ... ' + selectedCircle );
            const touchPos = getTouchPos(canvas, e);
            startPos = touchPos
            //console.log( "START: " + touchPos.x + "  " + touchPos.y )


            let working = false

            selectedCircle = circles.sort( ( a, b ) => b.id - a.id). 
              find(circle =>
                Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) && circle.selected === !selecting )
                
            //console.log( "selectedCircle: " + selectedCircle + "     selecting: " + selecting)
            if ( selectedCircle !== undefined ) {
                //console.log( "selectedCircle.selected: " + selectedCircle.selected )
                if ( selecting && !selectedCircle.selected ){
                    selectedCircle.selected = true
                    //console.log("selected " + selectedCircle.id + "  true" )
                } else if ( !selecting && selectedCircle.selected ){
                    selectedCircle.selected = false
                    //console.log("selected " + selectedCircle.id + "  false" )
                }

            } else {

                if ( circles.find( circle => Math.hypot(circle.x - touchPos.x, circle.y - touchPos.y) < ( getRadiusInPixel( circle.radius ) ) ) !== undefined ) {
                    selecting = !selecting

                } else {
                    selecting = true

                    // deselcting all selected for mobile
                    circles.forEach(circle => {
                        circle.selected = false; // Nová hodnota
                    });
                    
                }   
                //console.log("switched selecting to: " + selecting)
            }

            // draw circles
            drawCircles()

            // 
            endMove = false
        }

        const hasSpecificValue = (arr, key, value) => arr.some(obj => obj[key] === value);

        /* handling move of circles especially those they are selected */
        function handleMove( e ){

            //console.log( ' ... moving ...' );

            // when move is ending do nothing here
            if ( endMove ){
                //console.log( "end move + resturn" )
                return
            }

            /* if no select circle do nothing*/
            if ( !hasSpecificValue( circles, 'selected', true ) ){
                //console. log( 'DO nothing by move, no selection' )
                return 
            }


            const touchPos = getTouchPos(canvas, e);
            

            /* check for significant move */
            threshold = 10
            if ( !moved && startPos !== null &&
                 Math.abs( startPos.x - touchPos.x ) < threshold &&
                 Math.abs( startPos.y - touchPos.y ) < threshold ) {
                return
            }

            circles.forEach( circle => {

                //const touchPos = getTouchPos(canvas, e);
                if ( circle.selected ) {
                    //console.log( "MOVE: " + touchPos.x + "  " + touchPos.y + "  startPod: " + startPos.x + " " + startPos.y + "  circle: " + circle.x + " " + circle.y )

                    if ( startVector === null ) {
                        startVector = { x: circle.x - startPos.x, y: circle.y - startPos.y }
                    }

                    circle.x = touchPos.x + startVector.x;
                    circle.y = touchPos.y + startVector.y;
                    //console.log( "MOVE: " + touchPos.x + "  " + touchPos.y + "  circle: " + circle.x + " " + circle.y )

                    // setting moved to be active
                    moved = true
                }
            })

            // draw circles by every move
            if ( moved ) {
                drawCircles();
            }   

        }

        /* handling end of move or mouse up */
        function handleEnd(){

            //console.log( '... end moving' );

            // this will be done once after move was performed
            if ( moved ) {
                //console.log( "mouse up - after move" )

                // ending move atribute switch on
                endMove = true

                circles.forEach(circle => {
                    circle.selected = false; // Nová hodnota
                });

                /* force draw circles - typically canceling selection */
                drawCircles()

                // forcing selecting state to be able select
                selecting = true

                // moving attribute switch of
                moved = false

                startVector = null
            }

            //drawCircles()

        }

        canvas.addEventListener('touchstart', handleStart );
        canvas.addEventListener('mousedown', handleStart );

        canvas.addEventListener('touchmove', handleMove );
        canvas.addEventListener('mousemove', handleMove );

        canvas.addEventListener('touchend', handleEnd );
        canvas.addEventListener('mouseup', handleEnd );

        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();
            let scaleFactor = event.deltaY < 0 ? 1.1 : 0.9; // Zoom in or out
            zoomCanvas(scaleFactor);
        });

    </script>
</body>

</html>
